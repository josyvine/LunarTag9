package com.lunartag.app.ui.admin;

import android.app.AlertDialog;
import android.app.TimePickerDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.SharedPreferences;
import android.os.Bundle;
import android.text.InputType;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.EditText;
import android.widget.LinearLayout;
import android.widget.TimePicker;
import android.widget.Toast;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.fragment.app.Fragment;
import androidx.recyclerview.widget.LinearLayoutManager;

import com.lunartag.app.databinding.FragmentScheduleEditorBinding;

import org.json.JSONArray;
import org.json.JSONException;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.List;

public class ScheduleEditorFragment extends Fragment {

    private static final String PREFS_SCHEDULE = "LunarTagSchedule";
    private static final String KEY_TIMESTAMP_LIST = "timestamp_list";
    private static final String PREFS_TOGGLES = "LunarTagFeatureToggles";
    private static final String KEY_ADMIN_ENABLED = "customTimestampEnabled";

    private FragmentScheduleEditorBinding binding;
    private ScheduleAdapter adapter;
    private List<Long> timestampList;

    @Override
    public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        binding = FragmentScheduleEditorBinding.inflate(inflater, container, false);
        return binding.getRoot();
    }

    @Override
    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);

        SharedPreferences featurePrefs = requireContext().getSharedPreferences(PREFS_TOGGLES, Context.MODE_PRIVATE);
        boolean isFeatureEnabled = featurePrefs.getBoolean(KEY_ADMIN_ENABLED, false);

        if (!isFeatureEnabled) {
            binding.getRoot().setVisibility(View.GONE);
            return;
        }
        
        binding.getRoot().setVisibility(View.VISIBLE);

        timestampList = loadTimestamps();

        adapter = new ScheduleAdapter(timestampList, new ScheduleAdapter.OnTimestampDeleteListener() {
            @Override
            public void onTimestampDeleted(int position) {
                timestampList.remove(position);
                adapter.notifyItemRemoved(position);
                saveTimestamps(timestampList);
                updateCountUI();
            }
        });

        binding.recyclerViewTimestamps.setLayoutManager(new LinearLayoutManager(getContext()));
        binding.recyclerViewTimestamps.setAdapter(adapter);

        updateCountUI();
        setupClickListeners();
    }

    private void setupClickListeners() {
        binding.buttonAddTimestamp.setOnClickListener(v -> showTimePickerAndAdd());
        binding.buttonAutoGenerate.setOnClickListener(v -> showAutoGenerateDialog());
    }

    private void updateCountUI() {
        if (binding == null) return;
        
        int count = timestampList.size();
        binding.textSlotsRemaining.setText("Slots available: " + count);

        if (count == 0) {
            binding.textNoTimestamps.setVisibility(View.VISIBLE);
            binding.recyclerViewTimestamps.setVisibility(View.GONE);
        } else {
            binding.textNoTimestamps.setVisibility(View.GONE);
            binding.recyclerViewTimestamps.setVisibility(View.VISIBLE);
        }
    }

    // --- Logic: Add Single Timestamp (UPDATED FOR DATE ROLLOVER) ---

    private void showTimePickerAndAdd() {
        Calendar cal = Calendar.getInstance();
        int hour = cal.get(Calendar.HOUR_OF_DAY);
        int minute = cal.get(Calendar.MINUTE);

        TimePickerDialog picker = new TimePickerDialog(getContext(), new TimePickerDialog.OnTimeSetListener() {
            @Override
            public void onTimeSet(TimePicker view, int hourOfDay, int minute) {
                
                // 1. Create a Calendar object for the user's selection (Defaults to Today)
                Calendar selectedTime = Calendar.getInstance();
                selectedTime.set(Calendar.HOUR_OF_DAY, hourOfDay);
                selectedTime.set(Calendar.MINUTE, minute);
                selectedTime.set(Calendar.SECOND, 0);
                selectedTime.set(Calendar.MILLISECOND, 0);
                
                // 2. Logic to detect "Tomorrow"
                if (!timestampList.isEmpty()) {
                    // CASE A: We have existing items (e.g. 11:00 PM).
                    // If we add 12:00 AM, we must ensure it's AFTER the last item.
                    long lastTimestamp = timestampList.get(timestampList.size() - 1);
                    
                    // While the selected time is 'older' than the last entry, push it to next day.
                    // This handles 11 PM -> 1 AM naturally.
                    while (selectedTime.getTimeInMillis() <= lastTimestamp) {
                        selectedTime.add(Calendar.DAY_OF_MONTH, 1);
                    }
                } else {
                    // CASE B: List is empty. Check against "Right Now".
                    // If it's 10 PM and I select 8 AM, I clearly mean Tomorrow 8 AM.
                    Calendar now = Calendar.getInstance();
                    if (selectedTime.before(now)) {
                        selectedTime.add(Calendar.DAY_OF_MONTH, 1);
                    }
                }
                
                addTimestamp(selectedTime.getTimeInMillis());
            }
        }, hour, minute, false);
        picker.show();
    }

    private void addTimestamp(long timestamp) {
        timestampList.add(timestamp);
        Collections.sort(timestampList); 
        adapter.notifyDataSetChanged();
        saveTimestamps(timestampList);
        updateCountUI();
    }

    // --- Logic: Auto-Generate Schedule (UPDATED RANGE) ---

    private void showAutoGenerateDialog() {
        AlertDialog.Builder builder = new AlertDialog.Builder(getContext());
        builder.setTitle("Auto-Generate Schedule");
        builder.setMessage("Interval (Minutes). Generates 8 AM - 8 AM (Next Day).");

        final EditText inputInterval = new EditText(getContext());
        inputInterval.setInputType(InputType.TYPE_CLASS_NUMBER);
        inputInterval.setHint("Interval (Default: 30)");
        
        LinearLayout container = new LinearLayout(getContext());
        container.setOrientation(LinearLayout.VERTICAL);
        container.setPadding(50, 20, 50, 20);
        container.addView(inputInterval);
        
        builder.setView(container);

        builder.setPositiveButton("Generate", new DialogInterface.OnClickListener() {
            @Override
            public void onClick(DialogInterface dialog, int which) {
                String intervalStr = inputInterval.getText().toString();
                int interval = 30; 
                if (!intervalStr.isEmpty()) {
                    try {
                        interval = Integer.parseInt(intervalStr);
                    } catch (NumberFormatException e) { }
                }
                
                // Generating 8:00 AM to 8:00 AM (Next Day) to cover night shifts
                generateSchedule(8, 0, 8, 0, interval);
            }
        });

        builder.setNegativeButton("Cancel", null);
        builder.setNeutralButton("Clear All", (dialog, which) -> {
            timestampList.clear();
            adapter.notifyDataSetChanged();
            saveTimestamps(timestampList);
            updateCountUI();
        });

        builder.show();
    }

    private void generateSchedule(int startHour, int startMin, int endHour, int endMin, int intervalMinutes) {
        timestampList.clear();
        
        Calendar current = Calendar.getInstance();
        current.set(Calendar.HOUR_OF_DAY, startHour);
        current.set(Calendar.MINUTE, startMin);
        current.set(Calendar.SECOND, 0);
        current.set(Calendar.MILLISECOND, 0);

        // Logic: If "Now" is 9 PM, and we generate starting at 8 AM, start tomorrow.
        // (Optional: Remove this if you want to generate past slots for today)
        // Calendar now = Calendar.getInstance();
        // if (current.before(now)) { current.add(Calendar.DAY_OF_MONTH, 1); }

        Calendar end = Calendar.getInstance();
        // Copy date from 'current' to ensure we start comparing apples to apples
        end.setTimeInMillis(current.getTimeInMillis());
        end.set(Calendar.HOUR_OF_DAY, endHour);
        end.set(Calendar.MINUTE, endMin);
        end.set(Calendar.SECOND, 0);
        end.set(Calendar.MILLISECOND, 0);

        // FIX: If End Time is before Start Time (e.g. 8 AM to 2 AM), add 1 Day to End.
        if (end.before(current) || end.equals(current)) {
            end.add(Calendar.DAY_OF_MONTH, 1);
        }

        while (current.before(end) || current.equals(end)) {
            timestampList.add(current.getTimeInMillis());
            current.add(Calendar.MINUTE, intervalMinutes);
        }

        Collections.sort(timestampList);
        adapter.notifyDataSetChanged();
        saveTimestamps(timestampList);
        updateCountUI();
        Toast.makeText(getContext(), "Generated " + timestampList.size() + " slots.", Toast.LENGTH_SHORT).show();
    }

    private void saveTimestamps(List<Long> list) {
        SharedPreferences prefs = requireContext().getSharedPreferences(PREFS_SCHEDULE, Context.MODE_PRIVATE);
        JSONArray jsonArray = new JSONArray();
        for (Long ts : list) {
            jsonArray.put(ts);
        }
        prefs.edit().putString(KEY_TIMESTAMP_LIST, jsonArray.toString()).apply();
    }

    private List<Long> loadTimestamps() {
        List<Long> list = new ArrayList<>();
        SharedPreferences prefs = requireContext().getSharedPreferences(PREFS_SCHEDULE, Context.MODE_PRIVATE);
        String json = prefs.getString(KEY_TIMESTAMP_LIST, "[]");
        try {
            JSONArray jsonArray = new JSONArray(json);
            for (int i = 0; i < jsonArray.length(); i++) {
                list.add(jsonArray.getLong(i));
            }
        } catch (JSONException e) {
            e.printStackTrace();
        }
        Collections.sort(list);
        return list;
    }

    @Override
    public void onDestroyView() {
        super.onDestroyView();
        binding = null;
    }
}